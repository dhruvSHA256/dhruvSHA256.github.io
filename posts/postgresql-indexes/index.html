<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Postgresql Indexes</title><meta content="Postgresql Indexes" name=title><meta content=website property=og:type><meta content=https://dhruvsha256.github.io/posts/postgresql-indexes/ property=og:url><meta property=og:site_name><meta content="Postgresql Indexes" property=og:title><meta content=summary_large_image property=twitter:card><meta content=https://dhruvsha256.github.io/posts/postgresql-indexes/ property=twitter:url><meta content="Postgresql Indexes" property=twitter:title><link href=https://dhruvsha256.github.io/posts/postgresql-indexes/ rel=canonical><link href="https://dhruvsha256.github.io/ atom.xml" rel=alternate title=RSS type=application/atom+xml><link href=https://dhruvsha256.github.io/css/style.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-25FRCXX5P4" async></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-25FRCXX5P4')</script><script src=https://dhruvsha256.github.io/js/script.js></script><body><div class=wrapper><header><nav class=navBar><a href=https://dhruvsha256.github.io>/home</a><a href=https://dhruvsha256.github.io/posts>/posts</a><a href=https://dhruvsha256.github.io/projects>/projects</a><a href=https://dhruvsha256.github.io/resume>/resume</a><a href=https://dhruvsha256.github.io/atom.xml>/feed</a></nav></header><main><div><a href=..>..</a>/<span class=metaData>postgresql-indexes</span></div><time datetime=2022-12-19>Published on: <span class=metaData>2022-12-19</span></time><h1>Postgresql Indexes</h1><h2 id=indexes>Indexes</h2><h3 id=what>What</h3><ul><li>a data structure, can make some queries fast</ul><h3 id=why>Why</h3><ul><li>cause, without index every query will be a sequential scan from disk<li>whole point of index is to make query faster than O(n)<li>so why not create an index for each type of query, cause indexes makes updating slow as we have to update indexes<li>it also increases disk usage, slows down backup and restore</ul><h2 id=single-column-index>Single Column Index</h2><ul><li>index made on a single attribute</ul><h2 id=multi-column-index>Multi Column Index</h2><ul><li>index made on a group of attribute</ul><h2 id=partial-index>Partial Index</h2><ul><li>index made on a subset of table<li>ex: index on all the incomplete appointments in appointments table</ul><h2 id=b-tree-index>B+ Tree Index</h2><ul><li>uses B+ Tree for creating indexes<li>default in postgresql<li>stores pointer to heap file and not actual data<li>better to store actual data for primary index as reading from heap file is another disk i/o<li>used for query with operations like <, <= , = ,>=,><li>can be used for range queries, first go to the start of range in O(log(n)) and then traverse to next node<li>can be used for patterns like ^foo or foo% (constant prefix) but not with %foo as BTree are sorted based on first char<li>not suitable for large values of key as btree copies the key value in nodes -> less keys per node -> tree with more depth</ul><h2 id=hash-index>Hash Index</h2><ul><li>uses hash table instead of btree<li>PostgreSQL’s hash function maps any database value to a 32-bit integer, the hash code (about 4 billion possible hash codes)<li>hashfunction(index attribute) -> bucket which contains pointer to the rows -> actual data in table<li>can be smaller in size than btree<li>Hash index select and insert performance can be better than a B-Tree index<li>suitable for update heavy queries which uses equality operator<li>should be used with equality operator and not with comparative operators, example <code>select * from table where key = 'hello'</code><li>suitable for large values as their too are converted to 32 bit int values</ul><h2 id=brin-index>BRIN Index</h2><ul><li>Block range index<li>A block range is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index<li>ex: a table storing a ZIP code column might have all codes for a city grouped together naturally.<li>When you set up a BRIN index, PostgreSQL reads your selected column’s maximum and minimum values for each 8k page of stored data. PostgreSQL then stores just 3 pieces of information into the BRIN index, the page number, the minimum value and the maximum value for your chosen column.<li>more suitable for read heavy data, which is not updated frequently as updating can mess up ranges<li>used for very large datasets where the data we are searching is in blocks, like timestamps and date ranges.<li>size of index is very small</ul><h2 id=gin-index>GIN Index</h2><ul><li>Generalized inverted index<li>used where we need to index composite value<li>used for jsonb and array and tsvector (full text search)<li>organizes keys (like normalized words) into btree<li>node of btree contains lexmins and these lexmins points to the tuple id they exist in<li>supports query with operators: <ul><li>@> (contains)<li><@ (contained)<li>&& (overlap)<li>|| (concat)</ul></ul><h2 id=gist-index>GiST Index</h2><ul><li>generalized search tree<li>a framework, not a single index<li>used for spatial data and geometrical data<li>postgresql includes GiST operator classes for several 2D geometric data types<li>capable of optimizing nearest neighbour searches<li>supports query with operators: <ul><li><< (left side)<li>&< (not exceed to right)<li>&> (not exceed to left)<li>>> (right side)<li><<| (below)<li>&<| (not exceed above)<li>|&> (not exceed below)<li>|>> (above)<li>@> (contains)<li><@ (contained)<li>~= (same)<li>&& (overlap)</ul></ul><h2 id=bloom-index>Bloom Index</h2><ul><li>sort of like hash but different<li>uses Bloom Filters<li>used for multicolumn indexing</ul><p class=tagsData><a href=/tags/database>/database/</a> <a href=/tags/tech>/tech/</a></p><script>const defaultTheme=document.getElementsByTagName("head").className;if(defaultTheme=="dark")var giscus_theme="noborder_dark";else var giscus_theme="noborder_light"</script><script>var script=document.createElement("script");script.src="https://giscus.app/client.js";script.setAttribute("data-repo","dhruvsha256/dhruvsha256.github.io");script.setAttribute("data-repo-id","R_kgDOIYOkrQ");script.setAttribute("data-category","General");script.setAttribute("data-category-id","DIC_kwDOIYOkrc4CacVm");script.setAttribute("data-mapping","pathname");script.setAttribute("data-strict","0");script.setAttribute("data-reactions-enabled","1");script.setAttribute("data-emit-metadata","0");script.setAttribute("data-input-position","bottom");script.setAttribute("data-lang","en");script.setAttribute("crossorigin","anonymous");script.setAttribute("data-theme","noborder_dark");document.body.appendChild(script)</script><noscript>Please enable JavaScript to view the comments powered by giscus.</noscript></main><footer><hr><div class=footContainer></div></footer></div>