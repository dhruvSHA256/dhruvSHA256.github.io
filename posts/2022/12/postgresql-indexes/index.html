<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Dhruv Sharma ">
<meta name="description" content="Indexes What a data structure, can make some queries fast Why cause, without index every query will be a sequential scan from disk whole point of index is to make query faster than O(n) so why not create an index for each type of query, cause indexes makes updating slow as we have to update indexes it also increases disk usage, slows down backup and restore Single Column Index index made on a single attribute Multi Column Index index made on a group of attribute Partial Index index made on a subset of table ex: index on all the incomplete appointments in appointments table B&#43; Tree Index uses B&#43; Tree for creating indexes default in postgresql stores pointer to heap file and not actual data better to store actual data for primary index as reading from heap file is another disk i/o used for query with operations like &amp;lt;, &amp;lt;= , = ,&amp;gt;=,&amp;gt; can be used for range queries, first go to the start of range in O(log(n)) and then traverse to next node can be used for patterns like ^foo or foo% (constant prefix) but not with %foo as BTree are sorted based on first char not suitable for large values of key as btree copies the key value in nodes -&amp;gt; less keys per node -&amp;gt; tree with more depth Hash Index uses hash table instead of btree PostgreSQL&amp;rsquo;s hash function maps any database value to a 32-bit integer, the hash code (about 4 billion possible hash codes) hashfunction(index attribute) -&amp;gt; bucket which contains pointer to the rows -&amp;gt; actual data in table can be smaller in size than btree Hash index select and insert performance can be better than a B-Tree index suitable for update heavy queries which uses equality operator should be used with equality operator and not with comparative operators, example select * from table where key = &#39;hello&#39; suitable for large values as their too are converted to 32 bit int values BRIN Index Block range index A block range is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index ex: a table storing a ZIP code column might have all codes for a city grouped together naturally." />
<meta name="keywords" content="blog, database, tech" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://dhruvsha256.github.io/posts/2022/12/postgresql-indexes/" />


    <title>
        
            Postgresql Indexes :: dhruv.Sha256  — Dhruv Sha256
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://dhruvsha256.github.io/main.4d467576ff1271e7fba333671de4e2256cdb6827159b0ba09f683c67644bf64a.css">



    <link rel="apple-touch-icon" sizes="180x180" href="https://dhruvsha256.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://dhruvsha256.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://dhruvsha256.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://dhruvsha256.github.io/site.webmanifest">
    <link rel="mask-icon" href="https://dhruvsha256.github.io/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://dhruvsha256.github.io/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="Postgresql Indexes">
<meta itemprop="description" content="Indexes What a data structure, can make some queries fast Why cause, without index every query will be a sequential scan from disk whole point of index is to make query faster than O(n) so why not create an index for each type of query, cause indexes makes updating slow as we have to update indexes it also increases disk usage, slows down backup and restore Single Column Index index made on a single attribute Multi Column Index index made on a group of attribute Partial Index index made on a subset of table ex: index on all the incomplete appointments in appointments table B&#43; Tree Index uses B&#43; Tree for creating indexes default in postgresql stores pointer to heap file and not actual data better to store actual data for primary index as reading from heap file is another disk i/o used for query with operations like &lt;, &lt;= , = ,&gt;=,&gt; can be used for range queries, first go to the start of range in O(log(n)) and then traverse to next node can be used for patterns like ^foo or foo% (constant prefix) but not with %foo as BTree are sorted based on first char not suitable for large values of key as btree copies the key value in nodes -&gt; less keys per node -&gt; tree with more depth Hash Index uses hash table instead of btree PostgreSQL&rsquo;s hash function maps any database value to a 32-bit integer, the hash code (about 4 billion possible hash codes) hashfunction(index attribute) -&gt; bucket which contains pointer to the rows -&gt; actual data in table can be smaller in size than btree Hash index select and insert performance can be better than a B-Tree index suitable for update heavy queries which uses equality operator should be used with equality operator and not with comparative operators, example select * from table where key = &#39;hello&#39; suitable for large values as their too are converted to 32 bit int values BRIN Index Block range index A block range is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index ex: a table storing a ZIP code column might have all codes for a city grouped together naturally."><meta itemprop="datePublished" content="2022-12-19T11:34:05+05:30" />
<meta itemprop="dateModified" content="2022-12-19T11:34:05+05:30" />
<meta itemprop="wordCount" content="617"><meta itemprop="image" content="https://dhruvsha256.github.io/"/>
<meta itemprop="keywords" content="database,tech," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://dhruvsha256.github.io/"/>

<meta name="twitter:title" content="Postgresql Indexes"/>
<meta name="twitter:description" content="Indexes What a data structure, can make some queries fast Why cause, without index every query will be a sequential scan from disk whole point of index is to make query faster than O(n) so why not create an index for each type of query, cause indexes makes updating slow as we have to update indexes it also increases disk usage, slows down backup and restore Single Column Index index made on a single attribute Multi Column Index index made on a group of attribute Partial Index index made on a subset of table ex: index on all the incomplete appointments in appointments table B&#43; Tree Index uses B&#43; Tree for creating indexes default in postgresql stores pointer to heap file and not actual data better to store actual data for primary index as reading from heap file is another disk i/o used for query with operations like &lt;, &lt;= , = ,&gt;=,&gt; can be used for range queries, first go to the start of range in O(log(n)) and then traverse to next node can be used for patterns like ^foo or foo% (constant prefix) but not with %foo as BTree are sorted based on first char not suitable for large values of key as btree copies the key value in nodes -&gt; less keys per node -&gt; tree with more depth Hash Index uses hash table instead of btree PostgreSQL&rsquo;s hash function maps any database value to a 32-bit integer, the hash code (about 4 billion possible hash codes) hashfunction(index attribute) -&gt; bucket which contains pointer to the rows -&gt; actual data in table can be smaller in size than btree Hash index select and insert performance can be better than a B-Tree index suitable for update heavy queries which uses equality operator should be used with equality operator and not with comparative operators, example select * from table where key = &#39;hello&#39; suitable for large values as their too are converted to 32 bit int values BRIN Index Block range index A block range is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index ex: a table storing a ZIP code column might have all codes for a city grouped together naturally."/>







    <meta property="article:published_time" content="2022-12-19 11:34:05 &#43;0530 IST" />












    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://dhruvsha256.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">hello</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner">
        
        
        
        
        
        
        
        
        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://dhruvsha256.github.io/about">about</a></li>
                <li><a href="https://dhruvsha256.github.io/posts">posts</a></li>
                <li><a href="https://dhruvsha256.github.io/resume" target="_blank">resume</a></li>
                <li><a href="https://dhruvsha256.github.io/projects">projects</a></li>
                

            </ul>
        </nav>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
                <span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
   <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
   3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
   13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
 </svg></span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        3 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://dhruvsha256.github.io/posts/2022/12/postgresql-indexes/">Postgresql Indexes</a>
      </h1>

      

      

      

      <div class="post-content">
        <h2 id="indexes">Indexes</h2>
<h3 id="what">What</h3>
<ul>
<li>a data structure, can make some queries fast</li>
</ul>
<h3 id="why">Why</h3>
<ul>
<li>cause, without index every query will be a sequential scan from disk</li>
<li>whole point of index is to make query faster than O(n)</li>
<li>so why not create an index for each type of query, cause indexes makes updating slow as we have to update indexes</li>
<li>it also increases disk usage, slows down backup and restore</li>
</ul>
<h2 id="single-column-index">Single Column Index</h2>
<ul>
<li>index made on a single attribute</li>
</ul>
<h2 id="multi-column-index">Multi Column Index</h2>
<ul>
<li>index made on a group of attribute</li>
</ul>
<h2 id="partial-index">Partial Index</h2>
<ul>
<li>index made on a subset of table</li>
<li>ex: index on all the incomplete appointments in appointments table</li>
</ul>
<h2 id="b-tree-index">B+ Tree Index</h2>
<ul>
<li>uses B+ Tree for creating indexes</li>
<li>default in postgresql</li>
<li>stores pointer to heap file and not actual data</li>
<li>better to store actual data for primary index as reading from heap file is another disk i/o</li>
<li>used for query with operations like &lt;, &lt;= , = ,&gt;=,&gt;</li>
<li>can be used for range queries, first go to the start of range in O(log(n)) and then traverse to next node</li>
<li>can be used for patterns like ^foo or foo% (constant prefix) but not with %foo as BTree are sorted based on first char</li>
<li>not suitable for large values of key as btree copies the key value in nodes -&gt; less keys per node -&gt; tree with more depth</li>
</ul>
<h2 id="hash-index">Hash Index</h2>
<ul>
<li>uses hash table instead of btree</li>
<li>PostgreSQL&rsquo;s hash function maps any database value to a 32-bit integer, the hash code (about 4 billion possible hash codes)</li>
<li>hashfunction(index attribute) -&gt; bucket which contains pointer to the rows -&gt; actual data in table</li>
<li>can be smaller in size than btree</li>
<li>Hash index select and insert performance can be better than a B-Tree index</li>
<li>suitable for update heavy queries which uses equality operator</li>
<li>should be used with equality operator and not with comparative operators, example <code>select * from table where key = 'hello'</code></li>
<li>suitable for large values as their too are converted to 32 bit int values</li>
</ul>
<h2 id="brin-index">BRIN Index</h2>
<ul>
<li>Block range index</li>
<li>A block range is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index</li>
<li>ex: a table storing a ZIP code column might have all codes for a city grouped together naturally.</li>
<li>When you set up a BRIN index, PostgreSQL reads your selected column&rsquo;s maximum and minimum values for each 8k page of stored data. PostgreSQL then stores just 3 pieces of information into the BRIN index, the page number, the minimum value and the maximum value for your chosen column.</li>
<li>more suitable for read heavy data, which is not updated frequently as updating can mess up ranges</li>
<li>used for very large datasets where the data we are searching is in blocks, like timestamps and date ranges.</li>
<li>size of index is very small</li>
</ul>
<h2 id="gin-index">GIN Index</h2>
<ul>
<li>Generalized inverted index</li>
<li>used where we need to index composite value</li>
<li>used for jsonb and array and tsvector (full text search)</li>
<li>organizes keys (like normalized words) into btree</li>
<li>node of btree contains lexmins and these lexmins points to the tuple id they exist in</li>
<li>supports query with operators:
<ul>
<li>@&gt; (contains)</li>
<li>&lt;@ (contained)</li>
<li>&amp;&amp; (overlap)</li>
<li>|| (concat)</li>
</ul>
</li>
</ul>
<h2 id="gist-index">GiST Index</h2>
<ul>
<li>generalized search tree</li>
<li>a framework, not a single index</li>
<li>used for spatial data and geometrical data</li>
<li>postgresql includes GiST operator classes for several 2D geometric data types</li>
<li>capable of optimizing nearest neighbour searches</li>
<li>supports query with operators:
<ul>
<li>&lt;&lt; (left side)</li>
<li>&amp;&lt; (not exceed to right)</li>
<li>&amp;&gt; (not exceed to left)</li>
<li>&gt;&gt; (right side)</li>
<li>&lt;&lt;| (below)</li>
<li>&amp;&lt;| (not exceed above)</li>
<li>|&amp;&gt; (not exceed below)</li>
<li>|&gt;&gt; (above)</li>
<li>@&gt; (contains)</li>
<li>&lt;@ (contained)</li>
<li>~= (same)</li>
<li>&amp;&amp;  (overlap)</li>
</ul>
</li>
</ul>
<h2 id="bloom-index">Bloom Index</h2>
<ul>
<li>sort of like hash but different</li>
<li>uses Bloom Filters</li>
<li>used for multicolumn indexing</li>
</ul>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://dhruvsha256.github.io/tags/database/">database</a></span>
        <span class="tag"><a href="https://dhruvsha256.github.io/tags/tech/">tech</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        617 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2022-12-19 11:34
        

         
          
        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://dhruvsha256.github.io/posts/2022/07/hello-world/">
                    <span class="button__icon">←</span>
                    <span class="button__text">hello world</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://dhruvsha256.github.io/posts/2022/08/happiness/">
                    <span class="button__text">Happiness</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

  </main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            
            
            
            <span><a href="https://dhruvsha256.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
            
        </div>
    </div>
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="https://dhruvsha256.github.io/bundle.min.bb2c6bc3ed452ca4759660e4020811f248bc2320081559e8a32d8b0092773852941133639d35e8370d03d3ddaa750b1edd6b343c5bd22a55d5bdeae8f648f49b.js" integrity="sha512-uyxrw&#43;1FLKR1lmDkAggR8ki8IyAIFVnooy2LAJJ3OFKUETNjnTXoNw0D092qdQse3Ws0PFvSKlXVvero9kj0mw=="></script>



    </body>
</html>
